#!/usr/bin/env python3
import os
import re
import signal
from pathlib import Path
from textwrap import TextWrapper
from os.path import commonprefix
from typing import Pattern
# import subprocess

import pyalpm
from pycman.config import PacmanConfig

import requests
import lxml.html

#Based on checkupdates
def setup_alpm():
    fake_db_path = Path("/tmp/checkup-db-{}/".format(os.getuid()))
    fake_db_path.mkdir(exist_ok=True)

    config = PacmanConfig("/etc/pacman.conf")
    real_db_path = Path(config.options["DBPath"])

    fake_local = fake_db_path/"local"
    if not fake_local.exists():
        fake_local.symlink_to(real_db_path/"local")

    #trap 'rm -f $CHECKUPDATES_DB/db.lck' INT TERM EXIT
    def signal_handler(signum, frame):
        (fake_db_path/"db.lck").unlink(missing_ok=True)
    for sig in [signal.SIGINT, signal.SIGTERM]:
        signal.signal(sig, signal_handler)

    config.options["DBPath"] = str(fake_db_path)
    return config.initialize_alpm()
def alpm_update_dbs(handle):
    for db in handle.get_syncdbs():
        t = handle.init_transaction()
        db.update(False)
        t.release()

#TODO: switch to str methods once python 3.9 is released
def removeprefix(text, prefix):
    return text[len(prefix):] if text.startswith(prefix) else text
def removesuffix(text, suffix):
    return text[:-len(suffix)] if text.endswith(suffix) else text

def prefix_diff(r, a:str, b:str):
    a_split = r.split(a)
    b_split = r.split(b)
    common = commonprefix([a_split, b_split])
    diff_a = ''.join(a_split[len(common):])
    diff_b = ''.join(b_split[len(common):])
    return ''.join(common), diff_a, diff_b

def remove_trivial_pkgrel(ver : str):
    return removesuffix(ver, "-1")

version_fragment = re.compile(r'(\w+)')
strip_suffix = "-1"
def version_diff(a : str, b: str):
    prefix, diff_a, diff_b = prefix_diff(version_fragment, a, b)
    return (prefix,
            remove_trivial_pkgrel(diff_a),
            remove_trivial_pkgrel(diff_b))

arrow = "â†’"
def format_version_change(oldver : str, newver : str):
    prefix, diff_old, diff_new = version_diff(oldver, newver)
    if prefix:
        # return '{}[{} {} {}]{}'.format(prefix, middle_old, arrow, middle_new, suffix)
        return '{}[{} {} {}]'.format(prefix, diff_old, arrow, diff_new)
    else:
        return '{} {} {}'.format(diff_old, arrow, diff_new)

#Libalpm implements version parsing but pyalpm doesn't provide a wrapper
def strip_release(ver : str):
    return ver.rpartition("-")[0]
def version_release(ver : str):
    return ver.rpartition("-")[2]
def is_haskell(pkg):
    return "ghc-libs" in pkg.depends
def print_pkgrel_bump(old, new, msg=''):
    print("{: <20} {: <7} [{} {} {}] {}"
            .format(old.name,
                    strip_release(old.version),
                    version_release(old.version),
                    arrow,
                    version_release(new.version),
                    msg))
# def last_commit_msg(pkg):
#     proc = subprocess.Popen(['asp', 'shortlog', pkg.name], stdout=subprocess.PIPE)
#     msg = proc.stdout.readline().decode().split(' ', 1)[1] #First part is commit hash
#     #Cut off prefix generated by upgpkg
#     #There is a slight chance this might cut the message too.
#     return msg.split(':')[-1].strip()

git_repos = ["packages", "community"]
logurl="https://git.archlinux.org/svntogit/{}.git/log/trunk"
def last_commit_msg(pkg):
    for repo in git_repos:
        response = requests.get(logurl.format(repo), {'h':'packages/'+pkg.name})
        if response.ok: break
    else:
        return "${color3}ERROR: Repo not found"
        # raise LookupError("Repo not found for package "+pkg.name)
    e = lxml.html.fromstring(response.content)
    return e.xpath('body/div/div/table/tr[2]/td/a/text()')[0]

upgpkg_prefix = re.compile(r'upgpkg')
def format_commit_msg(pkg):
    msg = last_commit_msg(pkg)
    upgpkg_prefix = "upgpkg: {} {}: ".format(pkg.name, pkg.version)
    return removeprefix(msg, upgpkg_prefix)

handle = setup_alpm()
alpm_update_dbs(handle)
recompiled = []
haskell_recompiled = []

for pkg in handle.get_localdb().pkgcache: #type: pyalpm.Package
    update = pyalpm.sync_newversion(pkg, handle.get_syncdbs()) #type: pyalpm.Package
    if update:
        if strip_release(pkg.version) == strip_release(update.version):
            if is_haskell(pkg):
                haskell_recompiled.append((pkg, update))
            else:
                recompiled.append((pkg,update))
        else:
            format_version_change(pkg.version, update.version)
            print("{: <20} {}".format(pkg.name, format_version_change(pkg.version, update.version)))
print()
indent = "${goto 30}"
wrapper = TextWrapper(width=150, initial_indent=indent, subsequent_indent=indent)
for old, new in recompiled:
    print_pkgrel_bump(old, new)
    msg = wrapper.fill(format_commit_msg(new)).replace('#','\\#') #apparently Conky does something special with '#'
    print("${color1}"+msg+"${color2}")
    # "${font DejaVu Sans Mono :size=10}${color1}"+msg+"${color2}${font}"

n = len(haskell_recompiled)
print()
if n > 3:
    print(n, "haskell packages")
else:
    for old, new in haskell_recompiled:
        print_pkgrel_bump(old, new)

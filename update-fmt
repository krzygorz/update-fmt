#!/usr/bin/env python3
import os
import re
import signal
from pathlib import Path
from textwrap import TextWrapper
from os.path import commonprefix
from typing import Pattern
from collections import defaultdict
# import subprocess

import pyalpm
from pycman.config import PacmanConfig

import requests
import lxml.html

#Based on checkupdates
def fake_db_handle():
    fake_db_path = Path("/tmp/checkup-db-{}/".format(os.getuid()))
    fake_db_path.mkdir(exist_ok=True)

    config = PacmanConfig("/etc/pacman.conf")
    real_db_path = Path(config.options["DBPath"])

    fake_local = fake_db_path/"local"
    if not fake_local.exists():
        fake_local.symlink_to(real_db_path/"local")

    #trap 'rm -f $CHECKUPDATES_DB/db.lck' INT TERM EXIT
    def signal_handler(signum, frame):
        (fake_db_path/"db.lck").unlink(missing_ok=True)
    for sig in [signal.SIGINT, signal.SIGTERM]:
        signal.signal(sig, signal_handler)

    config.options["DBPath"] = str(fake_db_path)
    return config.initialize_alpm()
def alpm_update_dbs(handle):
    for db in handle.get_syncdbs():
        t = handle.init_transaction()
        db.update(False)
        t.release()



def sorteditems(d, key, reverse=False):
    return sorted(d.items(), key=lambda item: key(item[1]), reverse=reverse)

def removesuffix(text, suffix):
    return text[:-len(suffix)] if text.endswith(suffix) else text
def removesuffixes(text, suffixes):
    for suffix in suffixes:
        text = removesuffix(text, suffix)
    return text

def prefix_diff(r, a:str, b:str):
    a_split = r.split(a)
    b_split = r.split(b)
    common = commonprefix([a_split, b_split])
    diff_a = ''.join(a_split[len(common):])
    diff_b = ''.join(b_split[len(common):])
    return ''.join(common), diff_a, diff_b

def remove_trivial_pkgrel(ver : str):
    return removesuffixes(ver, ["-1", ".arch1"])

version_fragment = re.compile(r'(\w+)')
strip_suffix = "-1"
def version_diff(a : str, b: str):
    prefix, diff_a, diff_b = prefix_diff(version_fragment, a, b)
    return (prefix,
            remove_trivial_pkgrel(diff_a),
            remove_trivial_pkgrel(diff_b))

#Libalpm implements version parsing but pyalpm doesn't provide a wrapper
def strip_release(ver : str):
    return ver.split("-")[0]
def version_release(ver : str):
    return ver.split("-")[1]
def is_haskell(pkg):
    return "ghc-libs" in pkg.depends



# def last_commit_msg(pkg):
#     proc = subprocess.Popen(['asp', 'shortlog', pkg.name], stdout=subprocess.PIPE)
#     msg = proc.stdout.readline().decode().split(' ', 1)[1] #First part is commit hash
#     #Cut off prefix generated by upgpkg
#     #There is a slight chance this might cut the message too.
#     return msg.split(':')[-1].strip()
git_repos = ["packages", "community"]
logurl="https://git.archlinux.org/svntogit/{}.git/log/trunk"
def try_repo(repo, pkg):
    response = requests.get(logurl.format(repo), {'h':'packages/'+pkg.base})
    if not response.ok:
        return None
    e = lxml.html.fromstring(response.content)
    return e.xpath('body/div/div/table/tr[2]/td/a/text()')[0]

# TODO: Try using github graphql api (requires login)
# logurl = "https://api.github.com/repos/archlinux/svntogit-{}/commits"
# def try_repo(repo, pkg):
#     response = requests.get(logurl.format(repo), {'per_page':1, 'path':pkg.base+"/trunk"})
#     if not response.ok:
#         return None
#     return response.json()[0]['commit']['message']

class RequestLimitError(Exception):
    pass
class RepoNotFoundError(Exception):
    pass

# Limit in case of mass rebuilds
global request_limit
request_limit = 50
def last_commit_msg(pkg):
    global request_limit
    for repo in git_repos:
        request_limit -= 1
        if request_limit <= 0:
            raise RequestLimitError("Request limit reached!")
        if msg := try_repo(repo, pkg):
            return msg
    raise RepoNotFoundError("Repo not found for package "+pkg.name)

def stripped_commit_msg(pkg):
    try:
        msg = last_commit_msg(pkg)
    except (RequestLimitError, RepoNotFoundError) as e:
        return e

    # god I hate regex
    prefix_re = r'^(?:(?:upgpkg ?[:-] ?)?' + re.escape(pkg.base)+" )?"+re.escape(pkg.version) + r' ?[:-] ?'
    return re.sub(prefix_re, "", msg)

def collect_updates(handle):
    updated = []
    recompiled = defaultdict(set)
    haskell_recompiled = []
    for old in handle.get_localdb().pkgcache: #type: pyalpm.Package
        if new := pyalpm.sync_newversion(old, handle.get_syncdbs()):
            upd = (old, new)
            if strip_release(old.version) == strip_release(new.version):
                if is_haskell(old):
                    haskell_recompiled.append(upd)
                else:
                    msg = stripped_commit_msg(new)
                    recompiled[msg].add(upd)
            else:
                updated.append(upd)
    return updated, recompiled, haskell_recompiled



# Apparently Conky does something special with '#', must be escaped, otherwise everything after the # is not displayed
# package names and versions don't require escaping since they can't contain '#', but commit messages can (eg. when referencing an issue: FS#1234).
def conky_escape(str):
    return str.replace('#','\\#')

arrow = "â†’"
normal_color = "${color2}"
msg_color = "${color1}"
error_color = "${color3}"

# normal_color="\u001b[0m"
# msg_color="\u001b[90m"
# error_color="\u001b[31m"

indent = "   "
# indent = "${goto 30}" # causes conky to cut off text at right edge
# TextWrapper removes all newlines from input text, could be a problem if support for multiline messages is added
wrapper = TextWrapper(width=60, initial_indent=indent, subsequent_indent=indent)

def print_pkgrel_bump(old, new, msg=''):
    print("{: <20} {: <7} [{} {} {}] {}"
            .format(old.name,
                    strip_release(old.version),
                    version_release(old.version),
                    arrow,
                    version_release(new.version),
                    msg))
def print_commit_msg(msg):
    if isinstance(msg, str):
        msg = msg_color + conky_escape(wrapper.fill(msg))
    else:
        msg = indent + error_color + "ERROR: " + str(msg)
    print(msg+normal_color)

def format_version_change(oldver : str, newver : str):
    prefix, diff_old, diff_new = version_diff(oldver, newver)
    if prefix:
        return '{}[{} {} {}]'.format(prefix, diff_old, arrow, diff_new)
    else:
        return '{} {} {}'.format(diff_old, arrow, diff_new)

def print_updates(updated):
    for old, new in updated:
        print("{: <20} {}".format(old.name, format_version_change(old.version, new.version)))
    if updated:
        print()

def print_recompiled(recompiled):
    for msg, upds in sorteditems(recompiled, len, True):
        for old, new in upds:
            print_pkgrel_bump(old, new)
        print_commit_msg(msg)
        if len(upds) > 1:
            print()
    if recompiled:
        print()

def print_haskell_recompiled(haskell_recompiled, max_pkgs):
    n = len(haskell_recompiled)
    if n > max_pkgs:
        print(n, "haskell packages")
    else:
        for old, new in haskell_recompiled:
            print_pkgrel_bump(old, new)
    if haskell_recompiled:
        _, sample = haskell_recompiled[0]
        print_commit_msg(stripped_commit_msg(sample))

def main():
    handle = fake_db_handle()
    alpm_update_dbs(handle)
    updated, recompiled, haskell_recompiled = collect_updates(handle)

    print(normal_color, end='')
    print_updates(updated)
    print_recompiled(recompiled)
    print_haskell_recompiled(haskell_recompiled, 3)

if __name__ == "__main__":
    main()